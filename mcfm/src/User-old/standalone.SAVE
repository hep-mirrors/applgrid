#include <iostream>
#include <string>
#include <math.h>
#include "TFile.h"
#include "grid.h"
//
//
//
int main(int argc, char **argv) 
{

  double x, x1, x2, xA, xB;
  double born_weight, nlo_weight;
  const double pb_fac = 1.;
  static const int nSubProcess = 7;
  double subProcessWeight[nSubProcess];
  for(int i = 0; i<nSubProcess; ++i ) subProcessWeight[i] = 0;
  //initialise grid from file
  cout<<"\tReading in grid..."<<endl;
  char filename[200];
  sprintf(filename,"./weightgrid.root");
  grid* mygrid = new grid(filename);
  cout<<"\tReading in grid...Done"<<endl;
  
  //Find the number of runs...
  //  double runs = mygrid->run->GetBinContent(1);
  //  double scalefactor = pb_fac/runs;
  
  //Find the MCFM total XS
  double mcfmXS = mygrid->run->GetBinContent(1);
  
  //find the binning information...
  int nbins;
  nbins = mygrid->Nobs();
  double xbins[nbins + 1];
  
  // read in observables bins from grid 
  for(int i = 1; i <= nbins+1; i++)
    {
      xbins[i-1]=mygrid->m_obs_bins->GetBinLowEdge(i);
    }
  // book histograms for grid results
  TH1D *grid_tot = new TH1D("grid_tot", "grid_tot", nbins, xbins);
  TH1D *grid_ref = new TH1D("grid_ref", "grid_ref", nbins, xbins);
  
  
  //Normalise grids to number of runs and pb_fac
  for(int iobs = 0; iobs < nbins; iobs++) 
    {
      for(int isub = 0; isub < nSubProcess; isub++) 
	{
	  mygrid->m_weight[0][isub][iobs]->Scale(1.);//scalefactor);
	  mygrid->m_weight[1][isub][iobs]->Scale(1.);//scalefactor);
	}
    }
  
  // //   //Open up reference histograms file
  // //   cout << " Loading Reference Histos: " << filename << endl;
  // //   TFile myfile(filename); 
  
  // //   TH1D* refer;
  // //   char histname[100];
  // //   sprintf(histname,"refer");
  // //   refer = (TH1D*)myfile.Get(histname);
  // //   refer->SetDirectory(0);
  
  // //   myfile.Close();
  // //   cout << " loading RefHist finished " << endl;

  //
  //
  // calculate cross section from grid
  //
  //
      
  //  cout<<"Cross section after "<<int(runs + 0.5)<<" runs..."<<endl;
  double referenceIntegral = 0.0;

  for(int iobs = 0; iobs < nbins; iobs++)   // loop over observables bins
    {
      //      cout<<"iobs="<<iobs<< " " <<xbins[iobs]<< " < obs < " <<xbins[iobs+1]<<endl;
      double obssum = 0.0;
      
      for(int itau = 0; itau < mygrid->Ntau(iobs); itau++) // loop over Q2 bins
	{ 
	  // get scale
	  double Q2 = mygrid->fQ2(mygrid->m_weight[0][0][iobs]->GetZaxis()->GetBinCenter(itau+1));
	  double Qr=sqrt(Q2);
	  double Qf=sqrt(Q2);
	  
	  //
	  // calculate cross section from grid
	  //
	  for(int iy1 = 0; iy1 < mygrid->Ny(iobs); iy1++)   // loop over x1 bins
	    {
	      x1 = mygrid->fx(mygrid->fy(iobs,iy1));  // get X1
	      for(int iy2 = 0;iy2 < mygrid->Ny(iobs); iy2++) // loop over x2 bins
		{
		  x2 = mygrid->fx(mygrid->fy(iobs,iy2)); //get X2
		  
		  //
		  // now calculate the cross-section
		  //
		  for(int isub = 0; isub < nSubProcess; isub++) 
		    {
		      born_weight = mygrid->m_weight[0][isub][iobs]->GetBinContent(iy1+1, iy2+1, itau+1);
		      obssum += born_weight;
		      //		      if(isub==6)cout<<born_weight<<endl;
		      subProcessWeight[isub] += born_weight;
		      nlo_weight =  mygrid->m_weight[1][isub][iobs]->GetBinContent(iy1+1, iy2+1, itau+1);
		      obssum += nlo_weight;
		      subProcessWeight[isub] += nlo_weight;
		    }
		}
	    }
	}

      double binwidth   = mygrid->deltaobs(iobs+1);
      double gridweight = obssum/binwidth; //normalise by binwidth
      
      double refweight = 1.*(mygrid->m_obs_bins->GetBinContent(iobs + 1));
      referenceIntegral += refweight*binwidth;
      // fill histos for grid calcultion
      grid_tot->SetBinContent(iobs+1,gridweight);
      grid_ref->SetBinContent(iobs+1, refweight);
      
      //      cout<<"\tgrid="<<gridweight<<"\t reference: "<<refweight<<"\t\tgrid/reference="<<gridweight/refweight<<endl;
      //      cout<<"---------------------------"<<endl;
    }//end of loop over observable bins
  TFile myfile("./standalone.root","RECREATE");
  grid_tot->Write();
  grid_ref->Write();
  myfile.Close();
  
  double gridIntegral = 0.0;
  cout<<"---------------------------"<<endl;
  for (int i = 0; i < nSubProcess; ++i) 
    {
      gridIntegral += subProcessWeight[i];
      cout<<" weight for "<<i<<" = "<<subProcessWeight[i]<<endl;
    }
  cout<<"*************************"<<endl;
  cout<<"grid Intergal = "<<gridIntegral<<endl<<"reference integral = "<<referenceIntegral<<endl;
  cout<<" MCFM total XS = "<<mcfmXS<<endl;
  cout<<"---------------------------"<<endl;
  delete grid_tot, grid_ref;  
  delete mygrid;
  return 0;
}

