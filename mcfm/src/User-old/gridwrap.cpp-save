#include <iostream>
#include <iomanip>
#include "TFile.h"
#include "TMatrixT.h"
#include <stdlib.h> // exit()




#include <appl_grid.h>
using appl::grid;
using appl::igrid;


extern "C"
{
  extern struct 
  {
    double Vsq[11][11],Vsum[11];
  } ckm_;
  extern struct 
  {
    int nproc;
  } nproc_;
  extern struct 
  {
    int nflav;
  } nflav_;
  extern struct
  {
    bool creategrid;
    int nSubProcess;
  }grid_;
}

static const int mxpart = 12;        // mcfm parameter : max number of partons in event record

static const int Ngrids = 3;
appl::grid* mygrid[Ngrids];
static const char* gridFiles[Ngrids] = {"weight_eta4.root",
					"weight_pt4c.root",
					"weight_pt4f.root"};

static double Observable[Ngrids] = {0.0};   // observable array


int nObsBins[Ngrids] = {20, 26, 26}; // eta4, pt4 cental eta-bin, pt4 forward eta-bin


static const double eta[] = {-4.0,-3.6,-3.2,-2.8,-2.4,-2.0,-1.6,-1.2,-0.8,-0.4,0.0,0.4,0.8,1.2,1.6,2.0,2.4,2.8,3.2,3.6,4.0};
static const double pt[] = {0.,5.,10.,15.,20.,25.,30.,35.,40.,45.,50.,55.,60.,65.,70.,75.,80.,85.,90.,95.,100.,150.,200.,250.,300., 400., 500.};



// static int count111 = 0;
// int nEvent = 100;
// int upCount = 0*3*(nEvent-1), dnCount = 3*(nEvent);

long unsigned int runs = 0;
TH1D ***procReference;



extern "C" void book_grid__()  // inital grid booking
{
  
  std::cout<<" ***********************************************"<<std::endl;
  std::cout<<"Booking the grid = "<<std::endl;

  // binning information for the grid constructor
  int nXbins = 30;
  double xLow = 1.0e-5, xUp = 1.0;
  int nQ2bins = 3;
  double q2Low = 6399.99, q2Up = 6400.01;
  // number of subrocesses for the process of interest
  int nSubProcess = 6;
  // number of observables and binning for observables
  
  
  const double *obsBins[Ngrids];
  obsBins[0] = eta;
  obsBins[1] = pt;  
  obsBins[2] = pt;


  procReference = new TH1D**[Ngrids];

  for(int igrid=0; igrid < Ngrids; igrid++)
    {
      
      FILE * testfile; 
      testfile = fopen (gridFiles[igrid],"r"); 

     
      if (testfile==NULL)
	{
	  cout<<"Creating NEW grid... "<<endl;
	  
	  double apramval=5.;
	  mygrid[igrid] = new appl::grid( nSubProcess,                       // number of sub-processes
					  nXbins, xLow, xUp,                 // x bins
					  nQ2bins, q2Low, q2Up,              // Q2 bins
					  nObsBins[igrid], obsBins[igrid],   // obs bins
					  0.0625,                            // lambda
					  apramval,                          // varbin
					  0,                                 // pweight
					  5,5,0,                             // interpolation: x1,x2,Q2
					  (char*)gridFiles[igrid]);          // name of the file to save grid
  
	  grid_.nSubProcess = nSubProcess;
	  
	  std::cout<<*mygrid[igrid]<<std::endl;  
	}
      else
	{
	  cout<<"Creating OPTIMIZED grid in "<<gridFiles[igrid]<<"... "<<endl;
	  fclose(testfile);
	  mygrid[igrid] = new appl::grid(nXbins, nQ2bins, (char*)gridFiles[igrid]); //optimierte grid x,Q2 bins
	  grid_.nSubProcess = mygrid[igrid]->Nsub();
	  
	  std::cout<<*(mygrid[igrid])<<std::endl;  
	}

      double xbins[mygrid[igrid]->Nobs() + 1];
      for(int i = 1; i <= mygrid[igrid]->Nobs() + 1; i++)
	{
	  xbins[i-1] = mygrid[igrid]->getReference()->GetBinLowEdge(i);
	}

      gDirectory->cd(mygrid[igrid]->getFileName());
      procReference[igrid] = new TH1D*[mygrid[igrid]->Nsub()];
      
      for (int isub = 0; isub < mygrid[igrid]->Nsub(); isub++)
	{
	  char hname[50], htitle[50];
	  sprintf(hname,"procReference_%i",isub);
	  sprintf(htitle,"Contribution from SubProcess # %i",isub);
	  procReference[igrid][isub] = new TH1D(hname, htitle, mygrid[igrid]->Nobs(), xbins);
	  //	  procReference[igrid][isub]->SetDirectory();
	}

      gDirectory->cd("..");
    }
  
  runs = 0;
  
  std::cout<<" ***********************************************"<<std::endl;
}

extern "C" void write_grid__(double& xstotal)   // writes out grid after some events
{
  std::cout<<"\t Persistify the grid ..."<<std::endl;
  for(int igrid = 0; igrid < Ngrids; igrid++)
    {
      
      mygrid[igrid]->setRun(runs);
      mygrid[igrid]->setCrossSection(xstotal);
      mygrid[igrid]->setMCFM();
      mygrid[igrid]->setMCFMProcess(nproc_.nproc);
      mygrid[igrid]->setMCFMFlavours(nflav_.nflav);

      TMatrixT<double>* mat = mygrid[igrid]->getCKMsquared();
  
      for (int f1 = 0; f1 <= 10; f1++)
	{
	  for (int f2 = 0; f2 <= 10; f2++)
	    {
	      (*mat)(f2+1,f1+1) = ckm_.Vsq[f1][f2];
	    }
	}

      TVectorT<double>* vec = mygrid[igrid]->getCKMsum();
      for (int f1 = 0; f1 <= 10; f1++)
	{
	  (*vec)(f1+1) = ckm_.Vsum[f1];
	}
      
      mygrid[igrid]->save_weight();
      int nsub = mygrid[igrid]->Nsub();
      delete mygrid[igrid];
  
      TFile myfile(gridFiles[igrid],"UPDATE");
      {
	for (int isub = 0; isub < nsub; isub++)
	  {
	    procReference[igrid][isub] -> Write("",TObject::kOverwrite);
	  }
	
      }
      myfile.Close();
      
      std::cout<<"\t Persistify the grid N ="<<igrid+1<<" of total "<<Ngrids<<" ...done"<<std::endl;
    }
  std::cout<<" ***************************************************"<<std::endl;
}
//
//
//
//
//
//
//
 void getObservable(const double evt[][mxpart])
{
  // evt[momentum][particle number-1]
  // momentum[0,1,2,3] = (x,y,z,E)
  //

  // calculate observables
  for(int igrid = 0; igrid < Ngrids; igrid++)Observable[igrid] = 0.0; // initialize
  
  double p3[4] = {evt[3][2],evt[0][2],evt[1][2],evt[2][2]}; // (E,x,y,z)
  double p4[4] = {evt[3][3],evt[0][3],evt[1][3],evt[2][3]};
  
  
  double rapidity3 = 0.0;
  rapidity3 = (p3[0] + p3[3])/(p3[0] - p3[3]);
  (rapidity3 < 1e-13) ? rapidity3 = 100.0 : rapidity3 = 0.5*std::log(rapidity3);
  
  double rapidity4 = 0.0;
  rapidity4 = (p4[0] + p4[3])/(p4[0] - p4[3]);
  (rapidity4 < 1e-13) ? rapidity4 = 100.0 : rapidity4 = 0.5*std::log(rapidity4);

  double rapidity34 = 0.0;                      // rapidity of particle (3+4) in event record
  rapidity34  = (p3[0] + p4[0]) + (p3[3] + p4[3]);
  rapidity34 /= (p3[0] + p4[0]) - (p3[3] + p4[3]);
  
  (rapidity34 < 1e-13) ? rapidity34 = 100.0 : rapidity34 = 0.5*std::log(rapidity34);
  
  double pt3 = 0;
  pt3 = std::sqrt( p3[1]*p3[1] + p3[2]*p3[2] );
  
  double pt4 = 0;
  pt4 = std::sqrt( p4[1]*p4[1] + p4[2]*p4[2] );
  
  double pt34 = 0;
  pt34 = std::sqrt( std::pow(p3[1] + p4[1],2) + std::pow(p3[2] + p4[2],2) );
  
  
  
  Observable[0] = rapidity4;
  Observable[1] = pt4;
  Observable[2] = pt4;
  
}

int cuts(int igrid)
{
  int fill;
  switch(igrid)
    {
    case(0):
      fill = 1;
      break;
    case(1):
      (std::abs(Observable[0] <= 0.5)) ? fill = 1 : fill = 0;
      break;
    case(2):
      (std::abs(Observable[0] >= 3.0)) ? fill = 1 : fill = 0;
      break;
    default: 
      std::cerr<<" In gridwrap.cpp::cuts(int). No such process : "<<igrid<<std::endl;
      exit(-1);
    }
  return fill;
}






extern "C" void fill_grid__(const double &x1, 
			    const double &x2, 
			    const double& fac, 
			    const double evt[][mxpart], const double *wt, 
			    const int &order)
{
  double scale2 = fac*fac;
  getObservable(evt);
  
  for(int igrid = 0; igrid < Ngrids; igrid++)
    {
      if (!(mygrid[igrid]->isOptimised()))
	{
	  if(cuts(igrid)) mygrid[igrid]->fill_phasespace_event(x1, x2, scale2, Observable[igrid], wt, order);
	}
      else
	{
	  if(cuts(igrid)) mygrid[igrid]->fill_weight_event(x1, x2, scale2, Observable[igrid], wt, order);
	}
    }
  runs++; // counter of number of events
}

extern "C" void fill_grid_reference__(const double evt[][mxpart], 
				      const double &wt, 
				      const double &wt2) // fills reference
{
  getObservable(evt);
  for(int igrid = 0; igrid < Ngrids; igrid++)
    {
      if(!((Observable[igrid] > mygrid[igrid]->obsmax()) || (Observable[igrid] < mygrid[igrid]->obsmin())) && cuts(igrid)) 
	{
	  mygrid[igrid]->getReference()-> Fill(Observable[igrid], wt/mygrid[igrid]->deltaobs(Observable[igrid]));
	  mygrid[igrid]->getReference2()->Fill(Observable[igrid],wt2/mygrid[igrid]->deltaobs(Observable[igrid]));
	}
    }
}

extern "C" void fill_process_reference__(const double evt[][mxpart], 
					 const double *wt) // fills sub process reference
{
  getObservable(evt);
  for(int igrid = 0; igrid < Ngrids; igrid++)
    {
      if(!((Observable[igrid] > mygrid[igrid]->obsmax()) || (Observable[igrid] < mygrid[igrid]->obsmin())) && cuts(igrid)) 
	{
	  for (int isub = 0; isub < mygrid[igrid]->Nsub(); isub++)
	    {
	      double currentWeight = wt[isub]/(mygrid[igrid]->deltaobs(Observable[igrid]));
	      procReference[igrid][isub]->Fill(Observable[igrid], currentWeight);
	    }
	}
    }
}

